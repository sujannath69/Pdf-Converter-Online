<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DearPDF - Free & Private Client-Side PDF Tools</title>
    <meta name="description" content="A free, client-side PDF tool suite that works in your browser. Merge, split, compress, convert, protect, and edit PDFs without uploading your files.">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Styles & TailwindCSS Base */
        @tailwind base;
        @tailwind components;
        @tailwind utilities;

        /* Basic theme variables */
        :root {
            --bg-light: #f7fafc;
            --bg-dark: #1a202c;
            --text-light: #2d3748;
            --text-dark: #e2e8f0;
            --primary-color: #4299e1;
            --primary-hover: #2b6cb0;
        }

        /* Dark mode styles */
        html.dark {
            --bg-light: #1a202c;
            --bg-dark: #f7fafc;
            --text-light: #e2e8f0;
            --text-dark: #2d3748;
        }

        body {
            background-color: var(--bg-light);
            color: var(--text-light);
            transition: background-color 0.3s, color 0.3s;
        }
        
        /* Sidebar and content layout */
        .main-layout {
            display: grid;
            grid-template-columns: 250px 1fr;
        }
        
        @media (max-width: 768px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            #sidebar {
                position: fixed;
                top: 0;
                left: -250px;
                height: 100vh;
                transition: left 0.3s ease-in-out;
                z-index: 50;
                box-shadow: 0 0 15px rgba(0,0,0,0.2);
            }
            #sidebar.open {
                left: 0;
            }
            #mobile-menu-button { display: block; }
        }

        /* Tool card styling */
        .tool-card {
            @apply bg-white dark:bg-gray-700 p-6 rounded-lg shadow-md hover:shadow-xl hover:-translate-y-1 transition-all duration-300 cursor-pointer flex flex-col items-center text-center;
        }
        .tool-card-icon {
            @apply text-4xl mb-3 text-blue-500 dark:text-blue-400;
        }

        /* Drag & Drop Area */
        #drop-zone {
            @apply border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-10 text-center cursor-pointer transition-colors duration-300;
        }
        #drop-zone.dragover {
            @apply border-blue-500 bg-blue-50 dark:bg-gray-800;
        }

        /* Hide all tool sections by default */
        .tool-section { display: none; }
        .tool-section.active { display: block; }
        
        /* Loader styles */
        .loader {
            @apply border-4 border-gray-200 border-t-blue-500 rounded-full w-12 h-12 animate-spin;
        }

        /* File list item */
        .file-list-item {
            @apply bg-gray-100 dark:bg-gray-700 p-3 rounded-md flex justify-between items-center mb-2;
        }
    </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 text-gray-800 dark:text-gray-200 font-sans">
    
    <!-- PDF & JS Libraries (via CDN) -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mammoth@1.5.1/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@2/dist/tesseract.min.js'></script>

    <script>
        // Set worker path for pdf.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
    </script>
    
    <div id="app" class="min-h-screen">
        <div class="main-layout">
            <!-- Sidebar -->
            <aside id="sidebar" class="w-[250px] bg-white dark:bg-gray-800 shadow-lg p-4 flex flex-col">
                <h1 class="text-2xl font-bold text-blue-600 dark:text-blue-400 mb-6 cursor-pointer" onclick="showTool('home')">
                    DearPDF üíå
                </h1>
                <nav id="tool-list" class="flex flex-col space-y-2 text-gray-700 dark:text-gray-300">
                    <!-- Tool links will be injected here by JS -->
                </nav>
                <div class="mt-auto">
                    <div class="flex items-center justify-between">
                        <span>Dark Mode</span>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="darkModeToggle" class="sr-only peer">
                            <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600"></div>
                        </label>
                    </div>
                </div>
            </aside>

            <!-- Main Content -->
            <main id="main-content" class="p-4 md:p-8 overflow-y-auto">
                <!-- Mobile Header -->
                <header class="md:hidden flex justify-between items-center mb-4">
                    <h1 class="text-2xl font-bold text-blue-600 dark:text-blue-400" onclick="showTool('home')">DearPDF üíå</h1>
                    <button id="mobile-menu-button" class="p-2 hidden">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                    </button>
                </header>

                <!-- Loading Overlay -->
                <div id="loader-overlay" class="fixed inset-0 bg-gray-900 bg-opacity-50 flex flex-col justify-center items-center z-50 hidden">
                    <div class="loader"></div>
                    <p id="loader-text" class="text-white mt-4">Processing...</p>
                </div>

                <!-- Home Section -->
                <section id="home" class="tool-section active">
                    <div class="text-center mb-8">
                        <h2 class="text-4xl font-extrabold text-gray-900 dark:text-white">Your Go-To PDF Toolkit</h2>
                        <p class="mt-2 text-lg text-gray-500 dark:text-gray-400">All tools are free, private, and work in your browser. No file uploads needed.</p>
                    </div>
                    <div id="tool-grid" class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-6">
                        <!-- Tool cards will be injected here by JS -->
                    </div>
                </section>

                <!-- All Tool Sections Will Be Placed Here -->
                <div id="tool-container"></div>
            </main>
        </div>
    </div>

    <footer class="text-center p-4 text-sm text-gray-500 dark:text-gray-400 border-t border-gray-200 dark:border-gray-700 mt-auto">
        ¬© 2024 DearPDF. All rights reserved.
    </footer>
    
    <!-- Overlays for mobile menu -->
    <div id="sidebar-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-40 hidden md:hidden" onclick="toggleSidebar()"></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- LIBRARY SETUP ---
        const { PDFDocument, rgb, degrees, StandardFonts } = PDFLib;
        const { jsPDF } = window.jspdf;

        // --- GLOBAL STATE & ELEMENTS ---
        const App = {
            tools: [
                { id: 'merge-pdf', name: 'Merge PDF', icon: '‚úÖ', desc: 'Combine multiple PDFs into one.', multiple: true, accept: '.pdf' },
                { id: 'split-pdf', name: 'Split PDF', icon: '‚úÇÔ∏è', desc: 'Extract pages from a PDF.', multiple: false, accept: '.pdf' },
                { id: 'compress-pdf', name: 'Compress PDF', icon: 'üóúÔ∏è', desc: 'Reduce PDF file size (basic).', multiple: false, accept: '.pdf' },
                { id: 'protect-pdf', name: 'Protect PDF', icon: 'üîê', desc: 'Add a password to a PDF.', multiple: false, accept: '.pdf' },
                { id: 'unlock-pdf', name: 'Unlock PDF', icon: 'üîì', desc: 'Remove password from a PDF.', multiple: false, accept: '.pdf' },
                { id: 'rotate-pdf', name: 'Rotate PDF', icon: 'üîÅ', desc: 'Rotate all pages in a PDF.', multiple: false, accept: '.pdf' },
                { id: 'add-watermark', name: 'Add Watermark', icon: 'üíß', desc: 'Add text watermark to a PDF.', multiple: false, accept: '.pdf' },
                { id: 'add-page-numbers', name: 'Add Page Numbers', icon: 'üî¢', desc: 'Insert page numbers into a PDF.', multiple: false, accept: '.pdf' },
                { id: 'pdf-to-jpg', name: 'PDF to JPG', icon: 'üñºÔ∏è', desc: 'Convert each PDF page to a JPG.', multiple: false, accept: '.pdf' },
                { id: 'pdf-to-text', name: 'PDF to Text', icon: 'üìÑ', desc: 'Extract text from a PDF.', multiple: false, accept: '.pdf' },
                { id: 'ocr-pdf', name: 'OCR PDF', icon: 'üëì', desc: 'Recognize text in a scanned PDF.', multiple: false, accept: '.pdf,image/*' },
                { id: 'image-to-pdf', name: 'Image to PDF', icon: 'üñºÔ∏è', desc: 'Convert JPG, PNG to PDF.', multiple: true, accept: 'image/*' },
                { id: 'word-to-pdf', name: 'Word to PDF', icon: 'üìÑ', desc: 'Convert DOCX to PDF.', multiple: false, accept: '.docx' },
                { id: 'excel-to-pdf', name: 'Excel to PDF', icon: 'üìä', desc: 'Convert XLSX to PDF.', multiple: false, accept: '.xlsx' },
                { id: 'pdf-to-powerpoint', name: 'PDF to PowerPoint', icon: 'üéûÔ∏è', desc: 'Convert PDF to images for PPT.', multiple: false, accept: '.pdf' },
            ],
            activeTool: 'home',
            files: [],
            dom: {
                toolList: document.getElementById('tool-list'),
                toolGrid: document.getElementById('tool-grid'),
                toolContainer: document.getElementById('tool-container'),
                mainContent: document.getElementById('main-content'),
                loaderOverlay: document.getElementById('loader-overlay'),
                loaderText: document.getElementById('loader-text'),
                sidebar: document.getElementById('sidebar'),
                sidebarOverlay: document.getElementById('sidebar-overlay'),
                mobileMenuButton: document.getElementById('mobile-menu-button'),
                darkModeToggle: document.getElementById('darkModeToggle'),
            }
        };

        // --- HELPER FUNCTIONS ---
        const showLoader = (text = 'Processing...') => {
            App.dom.loaderText.textContent = text;
            App.dom.loaderOverlay.classList.remove('hidden');
        };

        const hideLoader = () => {
            App.dom.loaderOverlay.classList.add('hidden');
        };

        const showAlert = (message, type = 'error') => {
            alert(message); // Simple alert for now
        };

        const downloadFile = (blob, filename) => {
            saveAs(blob, filename);
        };

        const createToolSectionHTML = (tool) => {
            const optionsHTML = getToolOptionsHTML(tool.id);
            return `
                <section id="${tool.id}" class="tool-section">
                    <div class="max-w-4xl mx-auto">
                        <div class="text-center mb-8">
                            <h2 class="text-3xl font-bold">${tool.icon} ${tool.name}</h2>
                            <p class="text-gray-500 dark:text-gray-400 mt-2">${tool.desc}</p>
                        </div>
                        
                        <div id="drop-zone-${tool.id}" class="drop-zone mb-6">
                            <input type="file" id="file-input-${tool.id}" class="hidden" ${tool.multiple ? 'multiple' : ''} accept="${tool.accept}">
                            <p>Drag & drop your file(s) here or <span class="text-blue-500 font-semibold">click to browse</span></p>
                        </div>
                        
                        <div id="file-list-${tool.id}" class="mb-6"></div>

                        ${optionsHTML}

                        <button id="process-btn-${tool.id}" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition-colors duration-300 disabled:bg-gray-400" disabled>
                            Process File
                        </button>
                    </div>
                </section>
            `;
        };
        
        const getToolOptionsHTML = (toolId) => {
            switch (toolId) {
                case 'split-pdf':
                    return `
                        <div class="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg mb-4">
                            <h3 class="font-semibold mb-2">Split Options</h3>
                            <label for="split-range" class="block text-sm">Page range (e.g., 1-3, 5, 7-9):</label>
                            <input type="text" id="split-range" placeholder="e.g., 1-5" class="w-full p-2 rounded bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600">
                        </div>
                    `;
                case 'protect-pdf':
                    return `
                        <div class="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg mb-4">
                            <h3 class="font-semibold mb-2">Protection Options</h3>
                            <label for="pdf-password" class="block text-sm">Enter Password:</label>
                            <input type="password" id="pdf-password" class="w-full p-2 rounded bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600">
                        </div>
                    `;
                case 'unlock-pdf':
                     return `
                        <div class="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg mb-4">
                            <h3 class="font-semibold mb-2">Unlock Options</h3>
                            <label for="pdf-unlock-password" class="block text-sm">Enter Current Password:</label>
                            <input type="password" id="pdf-unlock-password" class="w-full p-2 rounded bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600" placeholder="Leave blank for unencrypted files">
                        </div>
                    `;
                case 'rotate-pdf':
                    return `
                        <div class="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg mb-4">
                            <h3 class="font-semibold mb-2">Rotation Options</h3>
                            <label for="rotation-angle" class="block text-sm">Angle:</label>
                            <select id="rotation-angle" class="w-full p-2 rounded bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600">
                                <option value="90">90 degrees clockwise</option>
                                <option value="180">180 degrees</option>
                                <option value="270">270 degrees clockwise</option>
                            </select>
                        </div>
                    `;
                case 'add-watermark':
                    return `
                        <div class="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg mb-4 grid grid-cols-2 gap-4">
                             <div>
                                <label for="watermark-text" class="block text-sm">Watermark Text:</label>
                                <input type="text" id="watermark-text" value="CONFIDENTIAL" class="w-full p-2 rounded bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600">
                            </div>
                            <div>
                                <label for="watermark-opacity" class="block text-sm">Opacity (0-1):</label>
                                <input type="number" id="watermark-opacity" value="0.5" step="0.1" min="0" max="1" class="w-full p-2 rounded bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600">
                            </div>
                            <div>
                                <label for="watermark-size" class="block text-sm">Font Size:</label>
                                <input type="number" id="watermark-size" value="50" class="w-full p-2 rounded bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600">
                            </div>
                             <div>
                                <label for="watermark-color" class="block text-sm">Color:</label>
                                <input type="color" id="watermark-color" value="#ff0000" class="w-full p-2 rounded bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600">
                            </div>
                        </div>
                    `;
                case 'add-page-numbers':
                     return `
                        <div class="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg mb-4">
                            <h3 class="font-semibold mb-2">Page Number Options</h3>
                            <label for="page-number-position" class="block text-sm">Position:</label>
                            <select id="page-number-position" class="w-full p-2 rounded bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600">
                                <option value="bottom-center">Bottom Center</option>
                                <option value="bottom-right">Bottom Right</option>
                                <option value="bottom-left">Bottom Left</option>
                                <option value="top-center">Top Center</option>
                                <option value="top-right">Top Right</option>
                                <option value="top-left">Top Left</option>
                            </select>
                        </div>
                    `;
                default:
                    return '';
            }
        };

        // --- TOOL LOGIC ---
        const toolImplementations = {
            'merge-pdf': async (files) => {
                showLoader('Merging PDFs...');
                const mergedPdf = await PDFDocument.create();
                for (const file of files) {
                    const pdfBytes = await file.arrayBuffer();
                    const pdf = await PDFDocument.load(pdfBytes, { ignoreEncryption: true });
                    const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());
                    copiedPages.forEach(page => mergedPdf.addPage(page));
                }
                const mergedPdfBytes = await mergedPdf.save();
                downloadFile(new Blob([mergedPdfBytes], { type: 'application/pdf' }), 'merged.pdf');
            },
            'split-pdf': async (files) => {
                showLoader('Splitting PDF...');
                const file = files[0];
                const rangeText = document.getElementById('split-range').value;
                if (!rangeText) throw new Error('Please enter a page range.');

                const pdfBytes = await file.arrayBuffer();
                const pdfDoc = await PDFDocument.load(pdfBytes, { ignoreEncryption: true });
                const pageCount = pdfDoc.getPageCount();

                const pagesToExtract = new Set();
                rangeText.split(',').forEach(part => {
                    if (part.includes('-')) {
                        const [start, end] = part.split('-').map(Number);
                        for (let i = start; i <= end; i++) {
                            if (i > 0 && i <= pageCount) pagesToExtract.add(i - 1);
                        }
                    } else {
                        const pageNum = Number(part);
                        if (pageNum > 0 && pageNum <= pageCount) pagesToExtract.add(pageNum - 1);
                    }
                });
                
                if (pagesToExtract.size === 0) throw new Error("Invalid page range or no pages selected.");

                const newPdfDoc = await PDFDocument.create();
                const copiedPages = await newPdfDoc.copyPages(pdfDoc, Array.from(pagesToExtract));
                copiedPages.forEach(page => newPdfDoc.addPage(page));
                
                const newPdfBytes = await newPdfDoc.save();
                downloadFile(new Blob([newPdfBytes]), 'split.pdf');
            },
            'compress-pdf': async (files) => {
                showLoader('Compressing PDF (basic)...');
                const file = files[0];
                const pdfBytes = await file.arrayBuffer();
                const pdfDoc = await PDFDocument.load(pdfBytes, { ignoreEncryption: true });
                // Re-saving with object streams can sometimes reduce size. True compression is more complex.
                const newPdfBytes = await pdfDoc.save({ useObjectStreams: true });
                downloadFile(new Blob([newPdfBytes]), 'compressed.pdf');
            },
            'protect-pdf': async (files) => {
                showLoader('Protecting PDF...');
                const file = files[0];
                const password = document.getElementById('pdf-password').value;
                if (!password) throw new Error('Please enter a password.');
                
                const pdfBytes = await file.arrayBuffer();
                const pdfDoc = await PDFDocument.load(pdfBytes);
                const options = {
                    userPassword: password,
                    ownerPassword: password,
                    permissions: {
                        printing: 'highResolution',
                        modifying: false,
                        copying: false,
                        annotating: false,
                    }
                };

                const protectedPdfBytes = await pdfDoc.save(options);
                downloadFile(new Blob([protectedPdfBytes]), 'protected.pdf');
            },
            'unlock-pdf': async (files) => {
                showLoader('Unlocking PDF...');
                const file = files[0];
                const password = document.getElementById('pdf-unlock-password').value;

                const pdfBytes = await file.arrayBuffer();
                const pdfDoc = await PDFDocument.load(pdfBytes, { password: password || undefined });
                
                const unlockedPdfBytes = await pdfDoc.save();
                downloadFile(new Blob([unlockedPdfBytes]), 'unlocked.pdf');
            },
            'rotate-pdf': async (files) => {
                showLoader('Rotating PDF...');
                const file = files[0];
                const angle = Number(document.getElementById('rotation-angle').value);

                const pdfBytes = await file.arrayBuffer();
                const pdfDoc = await PDFDocument.load(pdfBytes, { ignoreEncryption: true });
                const pages = pdfDoc.getPages();
                pages.forEach(page => {
                    const currentRotation = page.getRotation().angle;
                    page.setRotation(degrees(currentRotation + angle));
                });
                
                const rotatedPdfBytes = await pdfDoc.save();
                downloadFile(new Blob([rotatedPdfBytes]), 'rotated.pdf');
            },
            'add-watermark': async (files) => {
                showLoader('Adding Watermark...');
                const file = files[0];
                const text = document.getElementById('watermark-text').value;
                const opacity = parseFloat(document.getElementById('watermark-opacity').value);
                const size = parseInt(document.getElementById('watermark-size').value);
                const colorHex = document.getElementById('watermark-color').value;
                const color = { r: parseInt(colorHex.slice(1,3), 16)/255, g: parseInt(colorHex.slice(3,5), 16)/255, b: parseInt(colorHex.slice(5,7), 16)/255 };

                const pdfBytes = await file.arrayBuffer();
                const pdfDoc = await PDFDocument.load(pdfBytes, { ignoreEncryption: true });
                const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
                const pages = pdfDoc.getPages();
                
                for (const page of pages) {
                    const { width, height } = page.getSize();
                    const textWidth = helveticaFont.widthOfTextAtSize(text, size);
                    
                    page.drawText(text, {
                        x: width / 2 - textWidth / 2,
                        y: height / 2,
                        font: helveticaFont,
                        size: size,
                        color: rgb(color.r, color.g, color.b),
                        opacity: opacity,
                        rotate: degrees(45),
                    });
                }
                
                const watermarkedPdfBytes = await pdfDoc.save();
                downloadFile(new Blob([watermarkedPdfBytes]), 'watermarked.pdf');
            },
            'add-page-numbers': async (files) => {
                showLoader('Adding Page Numbers...');
                const file = files[0];
                const position = document.getElementById('page-number-position').value;
                
                const pdfBytes = await file.arrayBuffer();
                const pdfDoc = await PDFDocument.load(pdfBytes, { ignoreEncryption: true });
                const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
                const pages = pdfDoc.getPages();
                const pageCount = pages.length;

                for (let i = 0; i < pageCount; i++) {
                    const page = pages[i];
                    const { width, height } = page.getSize();
                    const pageNumText = `${i + 1} / ${pageCount}`;
                    const textSize = 12;
                    const textWidth = helveticaFont.widthOfTextAtSize(pageNumText, textSize);

                    let x, y;
                    const margin = 30;

                    if (position.includes('bottom')) y = margin;
                    if (position.includes('top')) y = height - margin;
                    if (position.includes('left')) x = margin;
                    if (position.includes('right')) x = width - margin - textWidth;
                    if (position.includes('center')) x = width / 2 - textWidth / 2;

                    page.drawText(pageNumText, { x, y, size: textSize, font: helveticaFont, color: rgb(0, 0, 0) });
                }

                const numberedPdfBytes = await pdfDoc.save();
                downloadFile(new Blob([numberedPdfBytes]), 'numbered.pdf');
            },
            'pdf-to-jpg': async (files, quality = 0.9) => {
                showLoader('Converting PDF to JPG...');
                const file = files[0];
                const pdfData = new Uint8Array(await file.arrayBuffer());
                const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
                const zip = new JSZip();

                for (let i = 1; i <= pdf.numPages; i++) {
                    showLoader(`Converting page ${i} of ${pdf.numPages}...`);
                    const page = await pdf.getPage(i);
                    const viewport = page.getViewport({ scale: 2.0 });
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    await page.render({ canvasContext: context, viewport: viewport }).promise;
                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', quality));
                    zip.file(`page_${i}.jpg`, blob);
                }

                showLoader('Zipping files...');
                const zipBlob = await zip.generateAsync({ type: 'blob' });
                downloadFile(zipBlob, 'pdf-to-jpg.zip');
            },
            'pdf-to-powerpoint': async (files) => {
                 showLoader('Converting PDF to images for PowerPoint...');
                 showAlert("This tool converts each PDF page into a high-quality JPG image. You can then insert these images into your PowerPoint presentation. A .pptx file will not be generated automatically.", "info");
                 await toolImplementations['pdf-to-jpg'](files, 0.95); // Use higher quality for PPT
            },
            'pdf-to-text': async (files) => {
                showLoader('Extracting text...');
                const file = files[0];
                const pdfData = new Uint8Array(await file.arrayBuffer());
                const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
                let fullText = '';

                for (let i = 1; i <= pdf.numPages; i++) {
                    showLoader(`Reading page ${i}...`);
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    fullText += textContent.items.map(item => item.str).join(' ') + '\n\n';
                }

                const blob = new Blob([fullText], { type: 'text/plain;charset=utf-8' });
                downloadFile(blob, 'extracted-text.txt');
            },
            'ocr-pdf': async (files) => {
                const file = files[0];
                showLoader('Preparing for OCR...');

                const worker = Tesseract.createWorker({
                    logger: m => {
                        if (m.status === 'recognizing text') {
                           showLoader(`OCR: ${m.status} (${(m.progress * 100).toFixed(0)}%)`);
                        } else {
                           showLoader(`OCR: ${m.status}...`);
                        }
                    }
                });

                await worker.load();
                await worker.loadLanguage('eng');
                await worker.initialize('eng');
                
                let imageDataSource;

                if (file.type.startsWith('image/')) {
                    imageDataSource = file;
                } else if (file.type === 'application/pdf') {
                    // For PDF, OCR the first page. A full implementation would let user choose pages.
                    showLoader('Converting PDF page 1 to image...');
                    const pdfData = new Uint8Array(await file.arrayBuffer());
                    const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
                    const page = await pdf.getPage(1);
                    const viewport = page.getViewport({ scale: 2.0 });
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    await page.render({ canvasContext: context, viewport: viewport }).promise;
                    imageDataSource = canvas;
                } else {
                    throw new Error("Unsupported file type for OCR.");
                }

                const { data: { text } } = await worker.recognize(imageDataSource);
                await worker.terminate();

                const blob = new Blob([text], { type: 'text/plain;charset=utf-s8' });
                downloadFile(blob, 'ocr-result.txt');
            },
            'image-to-pdf': async (files) => {
                showLoader('Converting images to PDF...');
                const pdfDoc = await PDFDocument.create();
                for (const file of files) {
                    const bytes = await file.arrayBuffer();
                    let image;
                    if (file.type === 'image/jpeg') {
                        image = await pdfDoc.embedJpg(bytes);
                    } else if (file.type === 'image/png') {
                        image = await pdfDoc.embedPng(bytes);
                    } else {
                        continue; // Skip unsupported image types
                    }
                    
                    const page = pdfDoc.addPage([image.width, image.height]);
                    page.drawImage(image, { x: 0, y: 0, width: image.width, height: image.height });
                }

                const pdfBytes = await pdfDoc.save();
                downloadFile(new Blob([pdfBytes]), 'images.pdf');
            },
            'word-to-pdf': async (files) => {
                showLoader('Converting Word to PDF...');
                const file = files[0];
                const arrayBuffer = await file.arrayBuffer();

                const result = await mammoth.convertToHtml({ arrayBuffer });
                const html = result.value;

                const tempContainer = document.createElement('div');
                tempContainer.innerHTML = html;
                tempContainer.style.width = '210mm'; // A4 width
                tempContainer.style.padding = '20mm';
                tempContainer.style.position = 'absolute';
                tempContainer.style.left = '-9999px'; // Hide it off-screen
                document.body.appendChild(tempContainer);

                showLoader('Rendering document...');
                const canvas = await html2canvas(tempContainer);
                document.body.removeChild(tempContainer);

                const imgData = canvas.toDataURL('image/png');
                const pdf = new jsPDF({ orientation: 'p', unit: 'px', format: [canvas.width, canvas.height] });
                pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
                pdf.save('word-to-pdf.pdf');
            },
            'excel-to-pdf': async (files) => {
                showLoader('Converting Excel to PDF...');
                const file = files[0];
                const data = await file.arrayBuffer();
                const workbook = XLSX.read(data);
                
                const tempContainer = document.createElement('div');
                tempContainer.style.width = '297mm'; // A4 landscape width
                tempContainer.style.padding = '10mm';
                tempContainer.style.position = 'absolute';
                tempContainer.style.left = '-9999px';
                tempContainer.style.backgroundColor = 'white';
                tempContainer.style.color = 'black'; // Ensure text is visible for rendering
                
                // Add some basic styling for the tables
                const style = document.createElement('style');
                style.innerHTML = `
                    table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
                    th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
                    th { background-color: #f2f2f2; }
                `;
                tempContainer.appendChild(style);

                workbook.SheetNames.forEach(sheetName => {
                    const worksheet = workbook.Sheets[sheetName];
                    const html = XLSX.utils.sheet_to_html(worksheet);
                    const sheetDiv = document.createElement('div');
                    sheetDiv.innerHTML = `<h2>${sheetName}</h2>` + html;
                    tempContainer.appendChild(sheetDiv);
                });

                document.body.appendChild(tempContainer);

                showLoader('Rendering spreadsheet...');
                const canvas = await html2canvas(tempContainer);
                document.body.removeChild(tempContainer);
                
                const imgData = canvas.toDataURL('image/png');
                const pdf = new jsPDF({ orientation: 'l', unit: 'px', format: [canvas.width, canvas.height] });
                pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
                pdf.save('excel-to-pdf.pdf');
            },
        };
        
        // --- UI INITIALIZATION ---
        const init = () => {
            // Populate tool lists
            App.tools.forEach(tool => {
                // Sidebar link
                const link = document.createElement('a');
                link.href = '#';
                link.dataset.tool = tool.id;
                link.className = 'p-2 rounded hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors duration-200 tool-link';
                link.innerHTML = `${tool.icon} <span class="ml-2">${tool.name}</span>`;
                App.dom.toolList.appendChild(link);

                // Home grid card
                const card = document.createElement('div');
                card.className = 'tool-card';
                card.dataset.tool = tool.id;
                card.innerHTML = `
                    <div class="tool-card-icon">${tool.icon}</div>
                    <h3 class="font-semibold text-lg text-gray-800 dark:text-gray-200">${tool.name}</h3>
                    <p class="text-sm text-gray-500 dark:text-gray-400 mt-1">${tool.desc}</p>
                `;
                App.dom.toolGrid.appendChild(card);
                
                // Create the actual tool section
                App.dom.toolContainer.innerHTML += createToolSectionHTML(tool);
            });
            
            // Add event listeners after sections are created
            addToolSectionEventListeners();

            // Set up dark mode
            if (localStorage.getItem('darkMode') === 'true' || 
               (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches && !localStorage.getItem('darkMode'))) {
                document.documentElement.classList.add('dark');
                App.dom.darkModeToggle.checked = true;
            }
            App.dom.darkModeToggle.addEventListener('change', toggleDarkMode);

            // Set up mobile menu
            App.dom.mobileMenuButton.addEventListener('click', toggleSidebar);
        };

        const toggleDarkMode = () => {
            document.documentElement.classList.toggle('dark');
            localStorage.setItem('darkMode', document.documentElement.classList.contains('dark'));
        };

        const toggleSidebar = () => {
            App.dom.sidebar.classList.toggle('open');
            App.dom.sidebarOverlay.classList.toggle('hidden');
        };

        const addToolSectionEventListeners = () => {
             App.tools.forEach(tool => {
                const dropZone = document.getElementById(`drop-zone-${tool.id}`);
                const fileInput = document.getElementById(`file-input-${tool.id}`);
                const processBtn = document.getElementById(`process-btn-${tool.id}`);

                dropZone.addEventListener('click', () => fileInput.click());
                dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
                dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
                dropZone.addEventListener('drop', e => {
                    e.preventDefault();
                    dropZone.classList.remove('dragover');
                    handleFiles(e.dataTransfer.files, tool.id);
                });
                fileInput.addEventListener('change', e => handleFiles(e.target.files, tool.id));

                processBtn.addEventListener('click', async () => {
                    if (App.files.length === 0) {
                        showAlert('No files selected.');
                        return;
                    }
                    try {
                        await toolImplementations[tool.id](App.files);
                    } catch (error) {
                        console.error('Error processing files:', error);
                        showAlert(`An error occurred: ${error.message}`);
                    } finally {
                        hideLoader();
                    }
                });
            });
        };
        
        const handleFiles = (files, toolId) => {
            const tool = App.tools.find(t => t.id === toolId);
            if (!tool) return;

            App.files = Array.from(files);
            if (!tool.multiple) {
                App.files = App.files.slice(0, 1);
            }
            
            updateFileList(toolId);
        };
        
        const updateFileList = (toolId) => {
            const fileListContainer = document.getElementById(`file-list-${toolId}`);
            const processBtn = document.getElementById(`process-btn-${toolId}`);
            fileListContainer.innerHTML = '';
            
            if (App.files.length > 0) {
                App.files.forEach((file, index) => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-list-item';
                    fileItem.innerHTML = `
                        <span class="truncate pr-2">${file.name}</span>
                        <button data-index="${index}" class="text-red-500 hover:text-red-700 remove-file-btn">√ó</button>
                    `;
                    fileListContainer.appendChild(fileItem);
                });
                processBtn.disabled = false;
            } else {
                processBtn.disabled = true;
            }

            // Add event listeners for new remove buttons
            fileListContainer.querySelectorAll('.remove-file-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = parseInt(e.target.dataset.index, 10);
                    App.files.splice(index, 1);
                    updateFileList(toolId);
                });
            });
        };

        const showTool = (toolId) => {
            App.activeTool = toolId;
            App.files = []; // Clear files when switching tools

            document.querySelectorAll('.tool-section').forEach(section => {
                section.classList.remove('active');
            });
            
            const activeSection = document.getElementById(toolId);
            if (activeSection) {
                activeSection.classList.add('active');
                if (toolId !== 'home') {
                    updateFileList(toolId); // Clear the list visually
                }
            } else {
                 document.getElementById('home').classList.add('active');
            }

            // For mobile, close sidebar after selection
            if (window.innerWidth <= 768 && App.dom.sidebar.classList.contains('open')) {
                toggleSidebar();
            }
        };

        // --- GLOBAL EVENT LISTENERS ---
        document.body.addEventListener('click', (e) => {
            const toolLink = e.target.closest('[data-tool]');
            if (toolLink) {
                e.preventDefault();
                showTool(toolLink.dataset.tool);
            }
        });
        
        // --- START THE APP ---
        init();
    });
    </script>
</body>
</html>